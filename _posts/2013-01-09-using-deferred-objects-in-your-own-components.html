---
layout: post
title: Using deferred objects in your own components
date: 2013-01-09
comments: false
legacy: true
---

<h1>{{ page.title }}</h1>
<div class='post'>
My previous post explained <a href="http://blog.mostlystatic.com/2013/01/introduction-to-jquery-deferred-objects.html">how to use the promise objects returned by jQuery methods</a>. You can also use deferred objects in your own components or libraries and expose a promise object to the rest of the code.<br /><br />Imagine you are animating several elements on you page. You can use deferred objects to add a completion handler to all of them in a clean way. (jQuery actually does this very well already - see below - but let's use this as an example.)<br /><br />First let's load jQuery and add two div's to animate:<br /><pre class="brush: html">&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.js"&gt;&lt;/script&gt;<br /><br />&lt;div id="div1" style="background:red; width: 40px; height: 40px;"&gt;&lt;/div&gt;<br />&lt;div id="div2" style="background:green; width: 40px; height: 40px;"&gt;&lt;/div&gt;</pre>Then add this Javascript code:<br /><pre class="brush: javascript">function myAnimate(element, css, duration) {<br />    var deferred = $.Deferred();<br /><br />    $(element).animate(css, {<br />        duration: duration,<br />        complete: function () {<br />            deferred.resolve();<br />        }<br />    });<br />    return deferred.promise();<br />}<br /><br />var animation1 = myAnimate(&quot;#div1&quot;, {<br />    &quot;width&quot;: &quot;200px&quot;<br />},<br />500);<br />var animation2 = myAnimate(&quot;#div2&quot;, {<br />    &quot;width&quot;: &quot;200px&quot;<br />},<br />1500);<br /><br />$.when(animation1, animation2).then(function () {<br />    $(&quot;#div1&quot;).html(&quot;Both done!&quot;);<br />});</pre>The myAnimate function returns are jQuery promise object. You can then group the two promise objects using <code>$.when</code>.<br /><br />Inside the myAnimate function we create a new deferred object using <code>$.Deferred</code>, do the actual animation and return a promise object (using <code>.promise</code> to generate the promise object).<br /><br />In the animation complete handler we then <a href="http://api.jquery.com/deferred.resolve/">resolve the deferred object</a>. This triggers the any <code>.done</code> handlers attached to the promise object which are used by <code>$.when</code> to decide whether to call the <code>$.then</code> handler function.<br /><h3>Rejecting a deferred object</h3>Calling <code>.resolve</code> indicates that the action has been completed successfully. If for some reason there is an error and the <code>$.then</code> handler code depends on it you can call <code>.reject</code> on the deferred object instead. This will trigger <code>.fail</code> on the promise &nbsp;and the success trigger passed to&nbsp;<code>$.then</code> will not be executed. You can however pass a function as a second argument to <code>$.then</code> that will be run on rejection.<br /><h3>jQuery already has functionality built in for waiting for several animations to finish</h3>So don't use the example above, use this instead:<br /><pre class="brush: javascript">$("#div1").animate({<br />    "width": "200px"<br />}, {<br />    duration: 500<br />});<br />$("#div2").animate({<br />    "width": "200px"<br />}, {<br />    duration: 1500<br />});<br /><br />$("#div1, #div2").promise().done(function () {<br />    $("#div1").html("Both done!");<br />});</pre><code>.animate</code> does not return a promise object and returns a jQuery object to maintain chainability. You can obtain a promise object for the animations by calling&nbsp;<code>.promise</code>&nbsp;on the jQuery object.<br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>
