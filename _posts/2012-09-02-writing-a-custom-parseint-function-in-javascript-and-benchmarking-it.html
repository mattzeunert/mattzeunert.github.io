---
layout: post
title: Writing a custom parseInt function in Javascript and benchmarking it
date: 2012-09-02
comments: false
legacy: true
---

<h1>{{ page.title }}</h1>
<div class='post'>
The function I wrote didn't include features like different radixes or negative numbers. In spite of the reduced requirements I expected the function to be slower than the native code, which turned out to be false.<br /><br><h3>Takeaways</h3><ul><li>MyParseInt was 67% faster than parseInt with radix 10 in Chrome, in Firefox it was about 3x as fast as parseInt</li><li>This does not apply to slower Javascript engines like the IE9 and Opera 11 ones where the native functions are faster</li><li>Arrays with precached results are too slow to be useful if finding the result only requires a few calculations</li><li>Once I had a faster simplified version of myParseInt I couldn't find a way to speed it up by more than 10 to 20%. So what follows might not be very effective and applies to Firefox, it the effects were small and inconsistent in Chrome</li><li>Calculating the first initial result value of the parsed number instead of assigning 0 and adding the &nbsp;initial value in the loop seemed to be beneficial</li></ul> You can have a look at the <a href="http://jsperf.com/myparseint">tests on jsperf.com</a>. Performance will likely vary with string length.  <br><br> <h3>First naive attempt</h3> <pre class="brush: javascript"><br />function myParseInt1(str)<br />{<br />    var res = 0;    <br />    var nums = {<br />        &quot;1&quot;: 1, &quot;2&quot;: 2, &quot;3&quot;: 3, &quot;4&quot;: 4, &quot;5&quot;: 5,<br />        &quot;6&quot;: 6,&quot;7&quot;: 7,&quot;8&quot;: 8,&quot;9&quot;: 9};<br />    for (var i=0; i&lt;str.length; i++)<br />    {<br />        var char = str.charAt(i);<br />        var value = nums[char];<br />        res += value;<br />        res *= 10;                 <br />    }<br />    res /= 10;<br />    return res;<br />}<br /></pre> <p>This was especially slow in Firefox, taking 10 times as much time as the native parseInt. In Chrome the code took 3 times as much time as parseInt. </p> <h3>Using ascii codes instead of a dictionary</h3> <pre class="brush:javascript"><br />function myParseInt2(str) {<br />    var res = 0;<br />    for (i=0; i&lt;str.length; i++)<br />    {<br />        var charCode = str.charCodeAt(i);<br />        var value = charCode - 48;<br />        res += value;<br />        res *= 10;<br />    }<br />    res /= 10;<br />    return res;<br />};<br /></pre> <p>My second attempt got me very close to the final result: 50% faster than parseInt. <br>The clear next step would be to cache <code>str.length</code></p> <h3>Attempted improvement with inconsistent/little effect</h3> <p>I added the caching in myParseInt3. myParseInt4 and myParseInt6 were failed attempts. In myParseInt5 I avoided the multiplication for the first digit, which allowed me to remove the division at the end. I doubt that this was an improvement... definitely not in Firefox. <br>In myParseInt5b I started caching the <code>last</code> variable: </p> <pre class="brush: javascript"><br />function myParseInt5b(str) {<br />    var res = 0;<br />    var strLength = str.length;<br />    var last = strLength - 1;<br />    for (i=0; i&lt;strLength; i++)<br />    {<br />        var charCode = str.charCodeAt(i);<br />        var value = charCode - 48;<br />        res += value;<br />        if (i !== last)<br />        {<br />            res *= 10;<br />        }<br />    }<br />    return res;<br />};<br /></pre> <p>This increased the speed a little, although it was still slower than myParseInt3 in Firefox.<br>I made three more changes to myParseInt5b:<br>a) avoid variables, instead write <code>res += str.charCodeAt(i) - 48;</code><br>b) calculate the initial res value (for the first digit) at the top of the function<br>c) Move the <code>res*10</code> to the top of the for loop, that way we can get the if out of the loop<br> (a) seemed to have the code slightly slower in Firefox and slightly faster in Chrome. But the difference was quite small and inconsistent. (b) made the code a bit faster in both browsers. (c)  helped in Firefox and did not make a significant difference in Chrome. </p> <h3>Final code</h3> <p>This code was fastest in Chrome. It contains improvements (b) and (c) from above: </p><pre class="brush: javascript"><br />function myParseInt5bDoFirstNoIf(str) {<br />    var res = str.charCodeAt(0) - 48;<br />    var strLength = str.length;<br />    for (i=1; i&lt;strLength; i++)<br />    {<br />        res *= 10;<br />        var charCode = str.charCodeAt(i)<br />        var value = charCode - 48;<br />        res += value;<br />    }<br />    return res;<br />};<br /></pre> <h3>Failed attempt myParseInt4: Using a dictionary instead of local variables</h3> <p>I don't know what I thought when I tried this. It made the code a lot slower, especially in Firefox - although it was still faster than native parseInt. </p> <pre class="brush: javascript"><br />(function(){<br />var vars = {};<br />window.myParseInt4 = function(str) {<br />    vars.res = 0;<br />    vars.strLength = str.length;<br />    for (i=0; i&lt;vars.strLength; i++)<br />    {<br />        vars.charCode = str.charCodeAt(i);<br />        vars.value = vars.charCode - 48;<br />        vars.res += vars.value;<br />        vars.res *= 10;<br />    }<br />    vars.res /= 10;<br />    return vars.res;<br />};<br />})()<br /></pre> <h3>Failed attempt myParseInt6: avoiding ascii to digit conversion</h3> <p>Instead of turning the ascii character code into a digit by subtracting 48 this code adds the ascii code to the result - weighed by the digit position. At the end of the function a precalculated value is subtracted from the result - the value depends on the length of the number string. This was 36% slower than the fastest result in Chrome, probably because the array lookups take up quite some time and the code change avoids little calculation. </p></p><pre class="brush: javascript"><br />(function(){<br />    var pow10Cache = [];<br />    for (var i=0; i&amp;lt;200; i++)<br />    {<br />        pow10Cache[i] = Math.pow(10, i);<br />    }<br />    var addCache = [];<br />    for (var strLength=0; strLength&amp;lt;200; strLength++)<br />    {<br />        var subs = 0;<br />        for (i=0; i&amp;lt;strLength; i++)<br />        {<br />            var reverseI = strLength - i - 1;<br />            subs += pow10Cache[reverseI] * 48;<br />        }<br />        addCache[strLength] = -subs;<br />    }<br />    <br />    window.myParseInt6 = function(str){<br />        var strLength = str.length;<br />        var res = addCache[strLength];<br />        var last = strLength - 1;<br />        for (i=0; i&amp;lt;strLength; i++)<br />        {<br />            var charCode = str.charCodeAt(i);<br />            var reverseI = last - i;<br />            res += charCode * pow10Cache[reverseI];<br />        }<br />        return res;<br />    }<br />})()<br /></pre></div>
<h2>Comments</h2>
<div class='comments'>
</div>
